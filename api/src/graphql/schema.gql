type User @isAuthenticated {
	uid: ID!
    username: String!
	firstname: String!
	lastname: String!
	email: String!
	passsword: String!
	birthdate: String!
	gender: String
	bio: String
	tags: [Tag] @relation(name: "HAS_TAG", direction: "OUT")
	elo: Int!
	prefAge: Int
	prefOrientation: String
	prefRadius: Int
	confirmToken: String!
	resetToken: String!
	likesCount: Int @cypher(statement: "MATCH (User)-[r:LIKED]->(this) RETURN COUNT(r)")
	likedUsers: [User] @relation(name: "LIKED", direction: "OUT")
	likedByUsers: [User] @relation(name: "LIKED", direction: "IN")
    conversations: [Conversation] @relation(name: "HAS_CONV", direction: "OUT")
}

type Tag @isAuthenticated {
	uid: ID!
	name: String!
}

type Conversation @isAuthenticated {
    uid: ID!
    lastMessage: Message @cypher(statement: "MATCH (this)-[:HAS_MSG]-(msgs:Message) RETURN msgs ORDER BY msgs.uid DESC LIMIT 1")
    messages: [Message] @relation(name: "HAS_MSG", direction: "OUT")
    members: [User] @relation(name: "HAS_CONV", direction: "IN")
}

type Message @isAuthenticated {
	uid: ID!
    author: User @relation(name: "AUTHORED", direction: "IN")
	content: String!
}

type Blocked @isAuthenticated @relation(name: "BLOCKED") {
    uid: ID!
    from: User!
    to: User!
    at: String!
}

type Query {
	me: User @cypher(statement: "MATCH (user:User {uid: $cypherParams.currentUserUid}) RETURN user")
}

type Mutation {
  signup (firstname: String!, email: String!, username: String!, password: String!): String
  login(username: String!, password: String!): String
}
